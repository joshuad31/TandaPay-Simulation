<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="no-class.css" type="text/css" />
</head>
<body>
<h1 id="background"><span class="header-section-number">1</span> Background</h1>
<p>All modern insurance architectures require that a provider hold funds in reserve for paying future claims. Even models that function outside modern insurance principles such as a takaful (risk sharing groups compliant with Islamic law) are required to use custodians who hold reserves for the purpose of paying future claims. No one has ever seen a working model of insurance that is capable of paying claims that has no custodians and holds no reserves. If it was possible to build a policy using zero-reserve architecture then almost nothing would be known about how these types of architectures would function and what incentive structures would govern the participants.</p>
<p>TandaPay is a zero-reserve architecture that is optimized to produce groups that collapse when invalid claims are submitted for payment. The TandaPay architecture was created to produce incentive structures that maximize for the attribute of intolerance when it comes to dishonest reports by the members. This makes TandaPay an excellent protocol for whistleblowing software because the threat of collapse should theoretically create a willingness for the group to self-censor in order to maintain its existence. Only claims that are viewed by a super majority (above 90% of participants) as valid should ever be approved for payment.</p>
<p>Given the assumption that 40% (or more) of the members are honest, the TandaPay protocol can be proven to have the property of group collapse in response to submission of an invalid claim. What is currently unknown is the minimum threshold of honest participants required to produce this type of collapse. If the threshold required to collapse a group can be proven to be very low, then the degree to which the group self-censors claims should be correspondingly very high.</p>
<p>This dynamic can allow entities outside of the community to have a greater sense of certainty as to a claims validity without knowing the contents of a claim. In this way, the architecture, which would threaten to collapse a group for approving an invalid claim is the same architecture that would bolster credibility of the group for approving a valid claim.</p>
<p>What is needed is a simulation that explores different group attributes to determine which architecture is best optimized to produce groups which collapse with the minimum number of honest participants.</p>
<h1 id="background-as-it-pertains-to-tandapay"><span class="header-section-number">2</span> Background as it pertains to tandaPay</h1>
<p>Zero-reserve escrow technology for setting up insurance mutuals is new. In addition to not holding reserves, the architecture permits members to defect against invalid claims. These defections result in a hefty cost upon members who decide to remain in the community. As members leave, premiums can sharply rise, and it is the rise of premiums that can trigger a chain of events that result in group collapse.</p>
<p>There is a potential novelty associated with determining the honesty of an insurance claim using defections. Insurance mutuals have previously not permitted policyholders to leave the group with a refund of their premium, so little is known about this mechanic. A mechanism that permits defectors within the context of a zero-reserve group has never previously been explored by an academic paper.</p>
<p>Coverage requirements are inflexible demands enforced by smart contracts that claims be paid in full. They mandate that any remaining members make up for the value of premiums that were refunded to defectors. This means that a defectors denial of payment to a claimant requires remaining members to pay an additional cost to make up for this loss.</p>
<p>When coverage requirements are mandated by the system, it causes premiums to increase as members leave the group. Potentially the pairing of these three attributes can produce groups with the property of collapse as a result of a failure to reach consensus on the validity of an insurance claim. It is currently unknown if groups with these attributes can deterministically produce collapse when less than one-third of participants are honest. It is also unknown if there is a threshold of honest participants required to reliably produce collapse.</p>
<p>If it can be shown that the required threshold of a dissenting minority capable of producing group collapse is between 20 to 30% of participants, then the implications related to game theory for determining the honesty of an insurance claim will likely be of profound consequence. The threat of collapse gives the minority an effective means of imposing self-censorship upon the majority. The smaller the minority of honest participants that are required who can effectively prevent a supermajority from colluding to approve an invalid claim, the more an approved claim provides a valuable signal to entities outside of the group. If group collapse (or lack thereof) can become a reliable heuristic (to outsiders) for determining the honesty of an insurance claim then the group has an effective means of generating a historical record that has statistical significance.</p>
<h1 id="goal-of-the-simulation"><span class="header-section-number">3</span> Goal of THE simulation</h1>
<p>It is currently unknown if combining zero-reserve architecture and coverage requirements with a mechanism that permits defections can deterministically produce group collapse when a group's consensus is fractured. If it can be shown that a small dissenting minority can produce sharply rising premiums that effectively result in group collapse, then the implications related to game theory may be of profound consequence. Having an architecture where the threshold of honest participants required to produce collapse is known is likely to be valuable. If TandaPay is one day widely available, models capable of providing the probability that an insurance claim is valid based upon the group's historical record located on the blockchain are therefore also likely to be valuable.</p>
<p>The goal of the simulation is to produce a large and robust data set where multiple variables are evaluated. This data set should correlate architecture with specific starting assumptions to specific group properties. Said another way, the starting assumptions are that smart contracts can enforce inflexible coverage requirements and rising premiums as people defect, skip, or quit (i.e., when a group fractures). Can these starting assumptions be correlated with groups that collapse with a known threshold of honest defectors?</p>
<p>Once correlation is demonstrated, further research may be able to prove a causal relationship between architecture with specific assumptions producing groups with specific properties.</p>
<h1 id="what-is-new-about-tandapay"><span class="header-section-number">4</span> What is new about TandaPay</h1>
<p>TandaPay uses the blockchain to eliminate third party custodians and the ability for smart contracts to enforce inflexible coverage requirements. Previous research into groups such as broodfonds (breadfunds) and ROSCAs did not focus on the attributes of smart contracts being used to strictly enforce that premiums rise as a result of a fracture. Smart contract inflexibility is generally an underappreciated attribute that TandaPay heavily exploits.</p>
<p>In addition, other approaches did not utilize subgroups. Subgroups are important because they provide novel group dynamics that have also been previously underappreciated such as:</p>
<ul>
<li>The decrease in the signal to noise ratio. Subgroups allow defections to be categorized as either honest or selfish.</li>
<li>This feature is not tested by the simulation, but is part of an initial set of assumptions.</li>
<li>Architectures that use subgroups prohibit members from obtaining coverage as individuals; effectively outsourcing the cost of underwriting policies to the group.</li>
<li>This feature is not tested by the simulation, but is part of an initial set of assumptions.</li>
<li>Architectures that use subgroups accelerate group collapse when consensus is fractured because invalid groups impose costs in terms of morale and increased premiums.</li>
<li>The simulation tests this hypothesis.</li>
<li>Architectures that use subgroups inhibit members from acting as individuals by effectively imposing a cost associated with selfish defections and removing that same cost for honest defections.</li>
<li>This feature is not tested by the simulation, but is part of an initial set of assumptions.</li>
</ul>
<h1 id="conclusion"><span class="header-section-number">5</span> Conclusion</h1>
<p>The virtue of architecture that can deterministically produce collapse when a group's consensus is fractured is underappreciated. There are thousands of valid configurations for these types of groups. Finding the optimal configuration for collapse will require research, modeling, and the creation of simulations.</p>
<div class="figure">
<img src="images/conclusion.png" />
</div>
<h1 id="relationship-between-ev4-and-pv5"><span class="header-section-number">6</span> Relationship between ev4 and pv5</h1>
<p>The simulation specifies a number of different variables, but the purpose of the simulation is to derive the relationship between the initial number of defectors and the number of members remaining once the group collapses.</p>
<h2 id="definition-of-pv5"><span class="header-section-number">6.1</span> Definition of PV5</h2>
<p>Pricing Variable (PV)5 translates premium prices into group collapse. As members leave, premiums rise for the remaining participants. A group is only allowed to lower the cost of their monthly premiums if no members have left the group in the past 30 days as a result of defections, skipped payments, or a failure to reorg (i.e., quit). PV5 specifies a threshold that the group is unable to stop members from skipping out on paying premiums. Although the variable specifies the degree that premiums are required to rise, this can be directly translated to the number of members remaining once the PV5 threshold is crossed by using the following formula:</p>
<p><img src="images/f1.png" height="45"></p>
<p>The above formula can be derived from:</p>
<p><img src="images/f2.png" height="45"></p>
<p>or</p>
<p><img src="images/f3.png" height="45"></p>
<p>and</p>
<p><img src="images/f4.png" height="45"></p>
<h2 id="definition-of-ev4"><span class="header-section-number">6.2</span> Definition of EV4</h2>
<p>Environmental Variable (EV)4 is the number of members who act as honest defectors at the start of the simulation. If enough members defect in the initial wave, their actions result in a chain of events that can push the group over the PV5 threshold. If this happens, the group is effectively unable to continue.</p>
<p>If the number of members specified in PV4 is insufficient, the group will not cross the PV5 threshold and will be capable of changing their coverage requirement thereby enabling members to lower their premiums and avert group collapse.</p>
<h1 id="input-module"><span class="header-section-number">7</span> Input module</h1>
<p>[Create user interface for entering in relevant simulation variables]</p>
<h1 id="environmental-variables-ev"><span class="header-section-number">8</span> Environmental variables (EV)</h1>
<p>Table 1 outlines the EVs used in the simulation and their allowed values.</p>
<p><em><strong>Table 1. Environmental Variables (EVs)</strong></em></p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Variable Name</strong></th>
<th align="left"><strong>Variable Definition</strong></th>
<th align="left"><strong>Allowed Values</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">EV1</td>
<td align="left">How many members are in the group?</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">EV2</td>
<td align="left">Average take home pay for group members?</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">EV3</td>
<td align="left">What is the chance of a claim each month?</td>
<td align="left">25 – 75</td>
</tr>
<tr class="even">
<td align="left">EV4</td>
<td align="left">What is the percentage of honest defectors?</td>
<td align="left">10 – 45</td>
</tr>
<tr class="odd">
<td align="left">EV5</td>
<td align="left">What is the percentage of low-morale members?</td>
<td align="left">10 – 30</td>
</tr>
<tr class="even">
<td align="left">EV6</td>
<td align="left">What is the percentage of members who are unwilling to act alone?</td>
<td align="left">20 – 80</td>
</tr>
<tr class="odd">
<td align="left">EV7</td>
<td align="left">What is the member threshold needed for dependent members to defect?</td>
<td align="left">2, 3, 4</td>
</tr>
<tr class="even">
<td align="left">EV8</td>
<td align="left">Poison group for x periods</td>
<td align="left">0, 1, 2, 3 Default = 3</td>
</tr>
<tr class="odd">
<td align="left">EV9</td>
<td align="left">Probability a low-morale member will quit if forced to reorg</td>
<td align="left">0.3333</td>
</tr>
<tr class="even">
<td align="left">EV10</td>
<td align="left">Coverage requirement</td>
<td align="left"><img src="images/f5.png" height="20"></td>
</tr>
<tr class="odd">
<td align="left">EV11</td>
<td align="left">Number of remaining members that play a unity role</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">EV12</td>
<td align="left">Number of remaining members that play a role of independent</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h1 id="pricing-variables-pv"><span class="header-section-number">9</span> Pricing variables (PV)</h1>
<p>The following outlines the different PVs used in the simulation, what questions they aim to answer, and their allowed values.</p>
<p><strong>Question PV1, PV2, PV3, and PV4 are answering:</strong> What is the premium price sensitivity relative to the previous month?</p>
<p><strong>PV1 and PV2:</strong> PV1 and PV2 determine the bottom of the threshold, which corresponds to the lowest price impact. The relationship between PV1 and PV2 is as follows:</p>
<ul>
<li>PV1 = If the premium price increases by <strong>&lt; insert % between 20 – 40% &gt;</strong></li>
<li>PV2 = Then <strong>&lt; insert % between 1 – 15% &gt;</strong> of policyholders leave</li>
</ul>
<p><strong>PV3 and PV4:</strong> PV3 and PV4 determine the top of the threshold, which corresponds to the greatest price impact. The relationship between PV3 and PV4 is as follows:</p>
<ul>
<li>PV3 = If the premium price increases by <strong>&lt;insert % between 30 – 60%&gt;</strong></li>
<li>PV4 = Then <strong>&lt;insert % between 5 – 25%&gt;</strong> of policyholders leave</li>
</ul>
<p><strong>Question PV5 and PV6 are answering:</strong> What is the premium price sensitivity relative to pre-facture?</p>
<ul>
<li>PV5 = If the premium price increases by <strong>&lt;insert percentage&gt;</strong></li>
<li>PV6 = Then <strong>&lt;insert percentage&gt;</strong> of policyholders leave</li>
</ul>
<p><strong>Note:</strong> Auto populate suggestions for PV3 and PV4 based on PV1 and PV2. Suggestions may be modified by the user.</p>
<p><img src="images/f6.png" height=25></p>
<p><img src="images/f7.png" height=25></p>
<p><strong>Note:</strong> Auto populate suggestions for PV5 and PV6 based on PV1 and PV2. Suggestions may be modified by the user.</p>
<p><img src="images/f8.png" height=25></p>
<p><img src="images/f9.png" height=25></p>
<p><strong>Note:</strong> When automating multiple runs, variables are ranked in order of importance as seen here.</p>
<h2 id="pv-rules"><span class="header-section-number">9.1</span> PV Rules</h2>
<p>Rules for PVs include the following:</p>
<ul>
<li>PV3 &gt; PV1 and PV4 &gt; PV2</li>
<li>PV5 &gt; PV3</li>
</ul>
<h1 id="goal-create-system-generator-module"><span class="header-section-number">10</span> Goal: Create system generator module</h1>
<p>Take initial variables as user inputs and use functions to produce database entries as outputs.</p>
<h2 id="database-module"><span class="header-section-number">10.1</span> Database module</h2>
<p>The database module is designed to create, store, and update data using system data and user data.</p>
<h3 id="system-data"><span class="header-section-number">10.1.1</span> System Data</h3>
<p>System data functions to keep a record of the results and determines what the system will do next.</p>
<ul>
<li>Period data occupies the rows of the database</li>
<li>System record occupies columns of the database</li>
</ul>
<h3 id="user-data"><span class="header-section-number">10.1.2</span> User Data</h3>
<p>User data determines what the user will do next.</p>
<ul>
<li>User number occupies rows of the database</li>
<li>User record occupies columns of the database</li>
</ul>
<h2 id="system-database"><span class="header-section-number">10.2</span> System database</h2>
<p>The system database creates 10 periods composed of 30 stages as shown in order below. Stages 5, 8, 11, 14, 17, 20, 23, 26, 29 are not use as a functional part of the simulation.</p>
<p>Stage 1. Pay premiums stage for Period 1</p>
<p>Stage 2. Finalize claims stage for Period 0</p>
<p>Stage 3. Reorg subgroups stage for Period 1</p>
<p>Stage 4. Pay premiums stage for Period 2</p>
<p>Stage 5. Finalize claims stage for Period 1</p>
<p>Stage 6. Reorg subgroups stage for Period 2</p>
<p>Stage 7. Pay premiums stage for Period 3</p>
<p>Stage 8. Finalize claims stage for Period 2</p>
<p>Stage 9. Reorg subgroups stage for Period 3</p>
<p>Stage 10. Pay premiums stage for Period 4</p>
<p>Stage 11. Finalize claims stage for Period 3</p>
<p>Stage 12. Reorg subgroups stage for Period 4</p>
<p>Stage 13. Pay premiums stage for Period 5</p>
<p>Stage 14. Finalize claims stage for Period 4</p>
<p>Stage 15. Reorg subgroups stage for Period 5</p>
<p>Stage 16. Pay premiums stage for Period 6</p>
<p>Stage 17. Finalize claims stage for Period 5</p>
<p>Stage 18. Reorg subgroups stage for Period 6</p>
<p>Stage 19. Pay premiums stage for Period 7</p>
<p>Stage 20. Finalize claims stage for Period 6</p>
<p>Stage 21. Reorg subgroups stage for Period 7</p>
<p>Stage 22. Pay premiums stage for Period 8</p>
<p>Stage 23. Finalize claims stage for Period 7</p>
<p>Stage 24. Reorg subgroups stage for Period 8</p>
<p>Stage 25. Pay premiums stage for Period 9</p>
<p>Stage 26. Finalize claims stage for Period 8</p>
<p>Stage 27. Reorg subgroups stage for Period 9</p>
<p>Stage 28. Pay premiums stage for Period 10</p>
<p>Stage 29. Finalize claims stage for Period 9</p>
<p>Stage 30. Reorg subgroups stage for period 10</p>
<h3 id="system-record-syrec-variables"><span class="header-section-number">10.2.1</span> System record (SyRec) variables</h3>
<p>Table 2 provides details regarding the System Record (SyRec) variables. These variables keep track of decisions made by the users. Choices users make have an impact on the cost that a member must pay to continue to receive coverage. As members leave the system record charts the groups progress and enforces that premiums rise in response.</p>
<p><em><strong>Table 2. System Record (SyRec) Variables</strong></em></p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Variable Name</strong></th>
<th align="left"><strong>Variable Definition</strong></th>
<th align="left"><strong>Initial Values</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">SyRec1</td>
<td align="left">Valid members remaining</td>
<td align="left">EV1</td>
</tr>
<tr class="even">
<td align="left">SyRec2</td>
<td align="left">Premium for a single member</td>
<td align="left"><img src="images/f10.png" height=30></td>
</tr>
<tr class="odd">
<td align="left">SyRec3</td>
<td align="left">Number of defected members</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec4</td>
<td align="left">Number of paid members</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec5</td>
<td align="left">Number of members skipped</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec6</td>
<td align="left">Number of invalid members</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec7</td>
<td align="left">Number of members that quit</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec8</td>
<td align="left">Number of reorged members</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec9</td>
<td align="left">Fracture debt from defections</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec10</td>
<td align="left">Fracture debt from skips new</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec11</td>
<td align="left">Fracture debt from skips prior</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec12</td>
<td align="left">Fracture debt from invalid new</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec13</td>
<td align="left">Fracture debt from invalid prior</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec14</td>
<td align="left">Fracture debt total</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec15</td>
<td align="left">Fracture debt per member</td>
<td align="left">No</td>
</tr>
<tr class="even">
<td align="left">SyRec16</td>
<td align="left">Claims this period</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec17</td>
<td align="left">Refund value available for new members</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SyRec18</td>
<td align="left">Refund value available for prior members</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">SyRec19</td>
<td align="left">Generic total payment</td>
<td align="left"><img src="images/f10.png" height=30></td>
</tr>
</tbody>
</table>
<h2 id="user-database"><span class="header-section-number">10.3</span> User database</h2>
<p>The user database consists of a user's primary and secondary roles and the current status of the user. These roles and the user's status determine what decisions they will need to make as the simulation progresses.</p>
<h3 id="user-record-usrec-variables"><span class="header-section-number">10.3.1</span> User record (UsRec) variables</h3>
<p>Table 3 provides details regarding the User Record (UsRec) variables.</p>
<p><em><strong>Table 3. User Record (UsRec) Variables</strong></em></p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Variable Name</strong></th>
<th align="left"><strong>Variable Definition</strong></th>
<th align="left"><strong>Initial Values</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">UsRec1</td>
<td align="left">Original assigned subgroup number</td>
<td align="left">Generated by the subgroup setup</td>
</tr>
<tr class="even">
<td align="left">UsRec2</td>
<td align="left">Number of members remaining from original subgroup</td>
<td align="left">Generated by the subgroup setup</td>
</tr>
<tr class="odd">
<td align="left">UsRec3</td>
<td align="left">Current assigned subgroup number</td>
<td align="left">Generated by the subgroup setup</td>
</tr>
<tr class="even">
<td align="left">UsRec4</td>
<td align="left">Number of members in current subgroup</td>
<td align="left">Generated by the subgroup setup</td>
</tr>
<tr class="odd">
<td align="left">UsRec5</td>
<td align="left">Status of subgroup Accepted values: Valid, Invalid, or NR</td>
<td align="left">Generated by the subgroup setup</td>
</tr>
<tr class="even">
<td align="left">UsRec6</td>
<td align="left">Primary role Accepted values: Defector, Low-Morale, or Unity</td>
<td align="left">Generated by the role assignment</td>
</tr>
<tr class="odd">
<td align="left">UsRec7</td>
<td align="left">Secondary roleAccepted values: Dependent or independent</td>
<td align="left">Generated by the role assignment</td>
</tr>
<tr class="even">
<td align="left">UsRec8</td>
<td align="left">Current statusAccepted values: Defected, Paid, Skipped, Paid-Invalid, Quit, Reorg, or NR</td>
<td align="left">Paid</td>
</tr>
<tr class="odd">
<td align="left">UsRec9</td>
<td align="left">Number of times they have reorged</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">UsRec10</td>
<td align="left">Value of invalid refund available</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">UsRec11</td>
<td align="left">Total payment specific user</td>
<td align="left">EV1</td>
</tr>
<tr class="even">
<td align="left">UsRec12</td>
<td align="left">A member's ability to pay this periodAccepted values: Yes, No, or NR</td>
<td align="left">Yes</td>
</tr>
<tr class="odd">
<td align="left">UsRec13</td>
<td align="left">Defector counter</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<h2 id="initialization-functions"><span class="header-section-number">10.4</span> Initialization functions</h2>
<p>The simulation utilizes the following initialization functions:</p>
<ul>
<li>Subgroup setup module</li>
<li>Role assignment module</li>
</ul>
<h3 id="subgroup-setup"><span class="header-section-number">10.4.1</span> Subgroup setup</h3>
<p><strong>Note:</strong> To see the subgroup setup function performed in Excel, <a href="https://docs.google.com/spreadsheets/d/1lF42BrWEsvW_A3224bGnQQ0-nhM72QkobPF10YRvvX0/edit?usp=sharing">see this document</a>.</p>
<p>The following steps detail the setup of the subgroup:</p>
<ol style="list-style-type: decimal">
<li>Start with the total number of members (EV1).</li>
<li>Divide the total number of members (EV1) by 5.</li>
<li>Divide the result of Step 2 by 2.3333 and round to the nearest integer.</li>
<li>Multiply the result of Step 3 by 5.</li>
<li>Subtract the result of Step 4 from Step 1.</li>
<li>Divide the remaining members by 6.</li>
<li>Divide the result of Step 6 by 2 and round to the nearest integer.</li>
<li>Multiply the result of Step 7 by 6.</li>
<li>Subtract the result of Step 8 from Step 5.</li>
<li>Divide the remaining members by 7.</li>
<li>Divide the result of Step 10 by 2 and round down to the nearest integer.</li>
<li>Multiply the result of Step 11 by 7.</li>
<li>Subtract the result of Step 12 from Step 9.</li>
<li>Using the modulo operator, divide the remaining members by 4 and take the result with the remainder.</li>
<li>If the remainder from Step 14 = 0, then do nothing and continue with Step 15.</li>
<li>If the remainder from Step 14 = 1, 2, or 3 members, then convert one group of 5 into a group of 6, 7, or 2 groups of 4.
<ol style="list-style-type: decimal">
<li>If there is a set of 5 member groups, then see Step 3 = A</li>
<li>If there is a set of 6 member groups, then see Step 7 = B</li>
<li>If there is a set of 7 member groups, then see Step 11 = C</li>
<li>If there is a set of 4 member groups, then see Step 14 = D</li>
</ol></li>
<li>If the remainder from Step 14 = 1, then set a A - 1 group and a B + 1 group.</li>
<li>If the remainder from Step 14 = 2, then set a A - 1 group and a C + 1 group.</li>
<li>If the remainder from Step 14 = 3, then set a A - 1 group and a D + 2 group.</li>
<li>Assign a specific subgroup number to each subgroup.</li>
<li>Assign the members to each numbered subgroup.</li>
<li>Update the user record based on the subgroup setup.</li>
<li>UsRec1 = Assigned in Step 16</li>
<li>UsRec2 = Assigned in Step 16</li>
<li>UsRec3 = Assigned in Step 16</li>
<li>UsRec4 = Assigned in Step 16</li>
<li>UsRec5 = Initially set to Valid</li>
</ol>
<h3 id="role-assignment"><span class="header-section-number">10.4.2</span> Role assignment</h3>
<p>The role assignment consists of 2 roles.</p>
<p>The 1st role consists of EV4, EV5, and EV11.</p>
<ul>
<li>EV4 – What is the percentage of honest defectors?</li>
<li>EV5 – What is the percentage of low-morale members?</li>
<li>EV11 – The number of remaining members that play a unity role</li>
</ul>
<p>The 2nd role consists of EV6 and EV12.</p>
<ul>
<li>EV6 – What is the percentage of members who are unwilling to act alone?</li>
<li>EV12 – The number of remaining members that play a role of independent</li>
</ul>
<h4 id="instructions-for-1st-role-assignment"><span class="header-section-number">10.4.2.1</span> Instructions for 1st role assignment</h4>
<ol style="list-style-type: decimal">
<li><img src="images/f11.png" height=20> with the role of Defector</li>
<li>Assign the Defector 1st role to participants at random.</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Remove these participants from 1st role assignment pool.</li>
</ol>
<ol start="3" style="list-style-type: decimal">
<li><img src="images/f12.png" height=20> with the role of Low-Morale</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Assign the Low-Morale 1st role to remaining participants at random.</li>
</ol>
<ol start="4" style="list-style-type: decimal">
<li>Any members who are not assigned a role are assigned with the role of Unity.</li>
<li><img src="images/f13.png" height=20></li>
</ol>
<h4 id="instructions-for-2nd-role-assignment"><span class="header-section-number">10.4.2.2</span> Instructions for 2nd role assignment</h4>
<ol start="6" style="list-style-type: decimal">
<li><img src="images/f14.png" height=20> with the role of Dependent</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Assign the Dependent 2nd role to members of any group where UsRec4 = 4.</li>
<li>If UsRec4 = 4 &gt; <img src="images/f15.png" height=20> then stop assigning any members the Dependent role.</li>
<li>If UsRec4 = 4 members &lt; <img src="images/f15.png" height=20>, then assign any remaining <img src="images/f15.png" height=20> assignments at random.</li>
</ol>
<ol start="7" style="list-style-type: decimal">
<li>Assign remaining members the role of Independent.</li>
<li><img src="images/f16.png" height=20></li>
</ol>
<h4 id="update-user-record-based-on-role-assignment"><span class="header-section-number">10.4.2.3</span> Update user record based on role assignment</h4>
<ol style="list-style-type: decimal">
<li>Determine the value of UsRec6 from assigning EV4, EV5, and EV11.</li>
<li>Determine the value of UsRec7 from assigning EV6 and EV12.</li>
</ol>
<h2 id="how-funds-move-through-the-system"><span class="header-section-number">10.5</span> How funds move through the system</h2>
<p>Coverage requirements mandate that the cost of members who defect or skip their premium payments become deficits for any remaining group members. Figure 1 below charts how payments, which were removed by defectors in Function 1, or were never paid by skipped members in Function 2 become accounted for as debt. This debt is then realized as increased premiums calculated in Function 9 and carried forward to the next period by Function 11. If this debt is high enough, it will produce additional members who skip payment of their premiums in Function 2 and the cycle will repeat.</p>
<div class="figure">
<img src="images/figure1.png" />
</div>
<p><strong>Figure 1. How Defections Generate Group Debt</strong></p>
<p>If a group has no claims in a given month, the premiums must be returned to members as refunds. The process of returning premiums back to members takes about one month before these refunds become available to lower the cost of future premiums. As show in Figure 2 below, Function 8 determines if the current period has a claim, and Function 11 moves that credit forward into the next period. Finally, the credit reduces the members premiums in Function 2 and thus the likelihood that members will skip payment of their premium.</p>
<div class="figure">
<img src="images/figure2.png" />
</div>
<p><strong>Figure 2. How Refunds Generate Credits</strong></p>
<h2 id="system-and-user-functions-module"><span class="header-section-number">10.6</span> System and user functions module</h2>
<p>The following sections explain the system and user functions module. The functions and database work together by utilizing the following:</p>
<ul>
<li>Most system or user functions evaluate the user record row by row.</li>
<li>The function then modifies the user record if certain conditions are met. This modification may also result in a modification of the system record.</li>
<li>Once all the rows of the user record are completely evaluated, move to the next function.</li>
<li>The functions move from the Pay Stage to the Finalize Stage and then the Reorg Stage.</li>
<li>When all stages are complete, advance to the next period in the system record.</li>
<li>The following includes a step-by-step breakdown of the system and user functions module.</li>
</ul>
<h3 id="system-and-user-function-breakdown"><span class="header-section-number">10.6.1</span> System and user function breakdown</h3>
<h4 id="usfunc1-detailed-description"><span class="header-section-number">10.6.1.1</span> UsFunc1 Detailed Description</h4>
<p><strong>Function name:</strong> UsFunc1 – User defection function</p>
<p><strong>Stage and period:</strong> Pay Stage 1 – Only run for Period 1</p>
<p><strong>UsFunc1 input:</strong> UsRec1, UsRec6, UsRec7, and EV7</p>
<p><strong>Initial check:</strong> Is the simulation currently on Period 1?</p>
<ul>
<li>If yes, then continue.</li>
<li>If no, ?</li>
</ul>
<p><em>Path 0</em></p>
<ol style="list-style-type: decimal">
<li>Path 0 start. Load user record.</li>
<li>Count total users in user record = &lt;end of user list&gt;</li>
<li>Start with user <strong>&lt;current user #&gt;</strong>.</li>
<li>If user <strong>&lt;current user #&gt;</strong> = Defector, then:
<ul>
<li>continue to Path 0.5.</li>
</ul></li>
<li>Elseif <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of user list&gt;</strong> then:
<ul>
<li>continue to Path 1.5.</li>
</ul></li>
<li>Else:
<ul>
<li>continue with <strong>&lt;current user #&gt; + 1</strong></li>
<li>go to Path 0 start.</li>
</ul></li>
</ol>
<p><em>Path 0.5</em></p>
<ol style="list-style-type: decimal">
<li>If user <strong>&lt;current user #&gt;</strong> UsRec7 = Dependent, then:
<ul>
<li>evaluate Path 1.</li>
</ul></li>
<li>Else:
<ul>
<li>add to Path 2 Run Set.</li>
</ul></li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of user list&gt;</strong> then:
<ul>
<li>continue to Path 1.5.</li>
</ul></li>
<li>Else:
<ul>
<li>continue with <strong>&lt;current user #&gt; + 1</strong></li>
<li>go to Path 0 start.</li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<ol style="list-style-type: decimal">
<li>For all users where UsRec6 = Defector and UsRec7 = Dependent do:
<ul>
<li>Read <strong>&lt;current user #&gt;</strong> UsRec3 = Load into <strong>&lt;GroupRead&gt;</strong>.</li>
</ul></li>
<li>For every user where UsRec3 = <strong>&lt;GroupRead&gt;</strong> do:
<ul>
<li>Increment UsRec13 by 1.</li>
</ul></li>
<li>Clear <strong>&lt;GroupRead&gt;</strong>.</li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of user list&gt;</strong> then:
<ul>
<li>continue to Path 1.5.</li>
</ul></li>
<li>Else:
<ul>
<li>continue with <strong>&lt;current user #&gt; + 1</strong></li>
<li>go to Path 0 start.</li>
</ul></li>
</ol>
<p><em>Path 1.5</em></p>
<ol style="list-style-type: decimal">
<li>For all users where UsRec6 = Defector and UsRec7 = Dependent do:
<ul>
<li>If UsRec13 ≥ EV7 then:
<ul>
<li>add to Path 2 Run Set.</li>
</ul></li>
<li>Else:
<ul>
<li>add to Path 3 run set,</li>
<li>load Path 2 Run Set.</li>
</ul></li>
</ul></li>
</ol>
<p><em>Path 2 Run Set</em></p>
<ol style="list-style-type: decimal">
<li>Decrement SyRec1 by 1.</li>
<li>Defecting for previous period.
<ul>
<li>Increment SyRec3 by 1.</li>
</ul></li>
<li>Skipping for current period.
<ul>
<li>Increment SyRec5 by 1.</li>
</ul></li>
<li>Referencing UsRec3,
<ul>
<li>Decrease UsRec4 by 1 for all users with same UsRec3 value.</li>
<li>Decrease UsRec2 by 1 for all users with same UsRec1 and UsRec3.</li>
<li>UsRec3 = 0</li>
<li>UsRec4 = 0</li>
<li>UsRec5 = NR</li>
<li>UsRec8 = NR</li>
<li>UsRec12 = NR</li>
</ul></li>
</ol>
<p><em>Path 3 Run Set</em></p>
<ol style="list-style-type: decimal">
<li>Load Path 3 Run Set.</li>
<li>For all users in Path 3 Run Set do:
<ul>
<li>UsRec6 = Low-Morale</li>
</ul></li>
<li>Continue to Path 4.</li>
</ol>
<p><em>Path 4</em></p>
<ol style="list-style-type: decimal">
<li>Clear Path 2 Run Set.</li>
<li>Clear Path 3 Run Set.</li>
<li>Continue to UsFunc2.</li>
</ol>
<h4 id="usfunc2-detailed-description"><span class="header-section-number">10.6.1.2</span> UsFunc2 Detailed Description</h4>
<p><strong>Function name:</strong> UsFunc2 – User skip function</p>
<p><strong>Stage:</strong> Pay Stage 2</p>
<p><strong>UsFunc2 workflow:</strong> The workflow of UsFunc2 is shown below in Figure 3.</p>
<div class="figure">
<img src="images/figure3.png" />
</div>
<p><strong>Figure 3. Workflow of UsFunc2</strong></p>
<p><strong>At start of simulation:</strong> PV1, PV2, PV3, and PV4</p>
<ol style="list-style-type: decimal">
<li>Find the slope of price sensitivity relative to the previous month.</li>
<li>Pricing slope = <img src="images/f17.png" height=30></li>
</ol>
<p><strong>Note:</strong> The y-axis represents the percentage of people who will skip their premiums. The x-axis represents the amount (in percent) that the premium price has increased.</p>
<p><em>Run each period</em></p>
<p><strong>Initial check:</strong> Is the simulation currently on Period 1?</p>
<ol style="list-style-type: decimal">
<li>If yes, then:
<ul>
<li>end the function.</li>
</ul></li>
<li>Else:
<ul>
<li>continue.</li>
</ul></li>
</ol>
<p><strong>UsFunc2 input:</strong> SyRec19 for the current period pay stage and SyRec19 for the previous period pay stage.</p>
<ol style="list-style-type: decimal">
<li>a = SyRec19 for the current period pay stage</li>
<li>b = SyRec19 for the previous period pay stage</li>
<li><img src="images/f18.png" height=20> = % Increase in Premiums</li>
<li>If % Increase in Premiums &lt; PV1, then:
<ul>
<li>continue to Path 2</li>
</ul></li>
<li>If % Increase in Premiums ≥ PV1, then:
<ul>
<li>continue to Path 1</li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<ol style="list-style-type: decimal">
<li><img src="images/f19.png" height=20> where:
<ul>
<li>y - PV2 = m(% Increase in Premiums - PV1)</li>
<li>y = (m * % Increase in Premiums - m * PV1) = PV2</li>
<li>y = Skip% = Percent of users who will skip</li>
</ul></li>
</ol>
<p><strong>Path 1 input:</strong> SyRec1 and Skip%</p>
<p><strong>Path 1</strong> <strong>Output:</strong> Skip#</p>
<ol style="list-style-type: decimal">
<li>Identify group where UsRec5 = Valid.</li>
<li>Randomly select (Skip#) number of users where UsRec5 = Valid.</li>
<li>Group of skip users = Set of users.</li>
<li>Set of users UsRec12 = No.</li>
</ol>
<p><em>Path 2</em></p>
<ol style="list-style-type: decimal">
<li>If <img src="images/f21.png" height=30"> &lt; PV5, then:
<ul>
<li>continue to Path 3.</li>
</ul></li>
<li>If <img src="images/f22.png" height=30"> ≥ PV5, then:
<ul>
<li>determine Skip# to the nearest whole number.</li>
<li>Skip# = SyRec1 * PV6</li>
</ul></li>
<li>Identify group where UsRec5 = Valid.</li>
<li>Randomly select (Skip#) number of users where UsRec5 = Valid.</li>
<li>Group of skip users = Set of users.</li>
<li>Set of users UsRec12 = No</li>
</ol>
<p><em>Path 3</em></p>
<ol style="list-style-type: decimal">
<li>If EV8 = 0, then:
<ul>
<li>do nothing.</li>
</ul></li>
<li>If EV8 in 1, 2, or 3, then:
<ul>
<li>decrease EV8 by 1.</li>
<li>At random, select 1 user record where UsRec5 = Valid.</li>
<li>Update user.</li>
<li>UsRec12 = No</li>
</ul></li>
</ol>
<p><strong>Note:</strong> Once Path 1, Path 2, and Path 3 are completed for all records, continue to SyFunc3.</p>
<h4 id="syfunc3-detailed-description"><span class="header-section-number">10.6.1.3</span> SyFunc3 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc3 – Validate premium function</p>
<p><strong>Stage:</strong> Pay Stage 3</p>
<p><strong>Input:</strong> UsRec12</p>
<p><em>Path 0 Initialization</em></p>
<ol style="list-style-type: decimal">
<li>Load user record.</li>
<li>Create user list from user record where UsRec5 = Valid.</li>
<li>Count users in list = <strong>&lt;end of user list&gt;</strong>.</li>
<li>Load user list.</li>
<li>Start with first user in user list <strong>&lt;current user #&gt;</strong>.</li>
<li>Continue to Path 0 Start.</li>
</ol>
<p><em>Path 0 Start</em></p>
<ol style="list-style-type: decimal">
<li>Evaluate user <strong>&lt;current user #&gt;</strong>.</li>
<li>If UsRec12 = No, then:
<ul>
<li>update UsRec8 = Skipped</li>
<li>add to Path 1 Run Set.</li>
</ul></li>
<li>Else:
<ul>
<li>If (UsRec12 must be yes), then:
<ul>
<li>update UsRec8 = Paid.</li>
</ul></li>
</ul></li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of user list&gt;</strong> , then:
<ul>
<li>load Path 1.</li>
</ul></li>
<li>Else:
<ul>
<li>continue with <strong>&lt;current user #&gt; + 1</strong></li>
<li>go to Path 0 Start.</li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<ol style="list-style-type: decimal">
<li>If UsRec12 = No, then:
<ul>
<li>Update UsRec8 = Skipped.</li>
<li>Decrement SyRec1 by 1.</li>
<li>Increment SyRec5 by 1.</li>
<li>Referencing UsRec3,
<ul>
<li>Decrease UsRec4 by 1 for all users with same UsRec3 value.</li>
<li>Decrease UsRec2 by 1 for all users with same UsRec1 and UsRec3.</li>
</ul></li>
</ul></li>
<li>UsRec3 = 0</li>
<li>UsRec4 = 0</li>
<li>UsRec5 = NR</li>
<li>UsRec8 = NR</li>
<li>UsRec12 = NR</li>
</ol>
<p><em>Path 2</em></p>
<ol style="list-style-type: decimal">
<li>Clear Path 1 Run Set.</li>
<li>Continue to SyFunc4.</li>
</ol>
<h4 id="syfunc4-detailed-description"><span class="header-section-number">10.6.1.4</span> SyFunc4 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc4 – Invalidate subgroup function</p>
<p><strong>Stage:</strong> Pay Stage 4</p>
<p><strong>SyFunc4 input:</strong> UsRec4, UsRec8, and UsRec11</p>
<ol style="list-style-type: decimal">
<li>If UsRec4 = 1, 2, or 3 and UsRec8 = Paid, then:
<ul>
<li>Assign UsRec8 = Paid-Invalid</li>
<li>Assign UsRec5 = Invalid</li>
<li>Assign UsRec10 = UsRec11</li>
<li>Increase SyRec6 by 1</li>
<li>Continue to Path 1.</li>
</ul></li>
<li>If UsRec4 = 4, 5, 6, or 7, then:
<ul>
<li>continue to Path 1.</li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<p><strong>Initial check:</strong> Is the simulation currently on Period 1?</p>
<ol style="list-style-type: decimal">
<li>If yes, then:
<ul>
<li>Advance to SyFunc5.</li>
<li>Advance (copy) values in current System Record row to finalize stage Period 0.</li>
</ul></li>
<li>If no, then:
<ul>
<li>period = x advance to SyFunc6</li>
<li>Advance (copy) values in current System Record row to Reorg Stage Period x row.</li>
</ul></li>
</ol>
<h4 id="syfunc5-detailed-description"><span class="header-section-number">10.6.1.5</span> SyFunc5 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc5 – Finalize premium function</p>
<p><strong>Stage and period:</strong> Finalize Stare – only run for Period 0</p>
<p><strong>Initial check:</strong> Is the simulation currently on Period 0?</p>
<ol style="list-style-type: decimal">
<li>If yes, then:
<ul>
<li>continue to SyFunc5 input.</li>
</ul></li>
<li>Else:
<ul>
<li>do nothing.</li>
</ul></li>
</ol>
<p><strong>SyFunc5 input:</strong> UsRec8 = Defected</p>
<ol style="list-style-type: decimal">
<li>If UsRec8 = Defected, then:
<ul>
<li>increase SyRec3 by 1.</li>
</ul></li>
<li>Otherwise:
<ul>
<li>do nothing.</li>
</ul></li>
</ol>
<p><strong>SyFunc5 output:</strong> SyRec9</p>
<ol style="list-style-type: decimal">
<li>Calculate SyRec9.
<ul>
<li>SyRec9 = SyRec3 * SyRec13</li>
</ul></li>
<li>Advance values in current System Record row to Reorg Stage Period 1 row.</li>
<li>Advance to UsFunc6.</li>
</ol>
<h4 id="usfunc6-detailed-description"><span class="header-section-number">10.6.1.6</span> UsFunc6 Detailed Description</h4>
<p><strong>Function name:</strong> UsFunc6 – User quit function</p>
<p><strong>UsFunc6 workflow:</strong> The workflow of UsFunc6 is shown below in Figure 4.</p>
<div class="figure">
<img src="images/figure4.png" />
</div>
<p><strong>Figure 4. UsFunc6 Workflow</strong></p>
<p><em>Path 0 Initialization</em></p>
<ol style="list-style-type: decimal">
<li>Load user record.</li>
<li>Create user list from user record where UsRec8 = Paid-Invalid.</li>
<li>Count users in list = <strong>&lt;end of user list&gt;</strong>.</li>
<li>Load user list.</li>
<li>Start with first user in user list <strong>&lt;current user #&gt;</strong>.</li>
</ol>
<p><em>Path 0 Start</em></p>
<ol style="list-style-type: decimal">
<li>Evaluate &lt;current user #&gt;.
<ul>
<li>If user <strong>&lt;current user #&gt;</strong> UsRec6 = Low-Morale, then:
<ul>
<li>add to Path 1 Run Set.</li>
</ul></li>
<li>Else:
<ul>
<li>add to Path 3 Run Set</li>
</ul></li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of user list&gt;</strong> , then:
<ul>
<li>load Path 1.</li>
</ul></li>
<li>Else:
<ul>
<li>continue to <strong>&lt;current user #&gt;</strong> + 1</li>
<li>go to Path 0 Start.</li>
</ul></li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<ol style="list-style-type: decimal">
<li>Load Path 1 Run Set.</li>
<li>For all users where UsRec6 = Low-Morale and UsRec8 = Paid-Invalid:
<ul>
<li>Count users in set = <strong>&lt;end of path 1 set list&gt;</strong>.</li>
</ul></li>
<li>Continue Path 1 User Evaluation.</li>
</ol>
<p><em>Path 1 User Evaluation</em></p>
<ol style="list-style-type: decimal">
<li>Start with user <strong>&lt;current user # path 1&gt;</strong> in set Path 1 Run Set.</li>
<li>Calculate a random number in the range of 0 to 1 = <strong>&lt;probability&gt;</strong>.</li>
<li>If <strong>&lt;probability&gt;</strong> ≥ EV9, then:
<ul>
<li>add user to Path 3 Set List.</li>
</ul></li>
<li>Else:
<ul>
<li>add user to Path 2a Set List</li>
<li>update UsRec8 = Quit.</li>
</ul></li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of path 1 set list&gt;</strong> , then:
<ul>
<li>load Path 2a.</li>
</ul></li>
<li>Else:
<ul>
<li>increment value for <strong>&lt;current user # path 1&gt;</strong> by 1 in set Path 1 Run.</li>
</ul></li>
<li>Clear <strong>&lt;probability&gt;</strong>.</li>
<li>Go to Path 1 User Evaluation.</li>
</ol>
<p><em>Path 2a</em></p>
<ol style="list-style-type: decimal">
<li>Load Path 2a Run Set list.</li>
<li>For all users where UsRec8 = Quit:
<ul>
<li>Count users in set = <strong>&lt;end of path 2 set list&gt;</strong>.</li>
</ul></li>
<li>For each user in Path 2 Run Set:
<ul>
<li>Decrement SyRec1 by 1.</li>
<li>Increment SyRec 7 by 1</li>
</ul></li>
<li>Continue to Path 2a User Evaluation.</li>
</ol>
<p><em>Path 2a User Evaluation</em></p>
<ol style="list-style-type: decimal">
<li>Start with user <strong>&lt;current user # path 2&gt;</strong> in set Path 2 Run Set list.</li>
<li>Read <strong>&lt;current user #&gt;</strong> UsRec3 = Load into <strong>&lt;GRead A&gt;</strong>.</li>
<li>Read <strong>&lt;current user #&gt;</strong> UsRec1 = Load into <strong>&lt;GRead B&gt;</strong>.</li>
<li>For every user in record where UsRec3 = <strong>&lt;GRead A&gt;</strong>:
<ul>
<li>Decrease UsRec4 by 1.</li>
</ul></li>
<li>For every user in record where UsRec3 = <strong>&lt;GRead A&gt;</strong> and UsRec1 = <strong>&lt;GRead B&gt;</strong>:</li>
<li>Decrease UsRec2 by 1.</li>
<li>Assign the current values for <strong>&lt;current user # path 2&gt;</strong> as follows:
<ul>
<li>UsRec3 = 0</li>
<li>UsRec4 = 0</li>
<li>UsRec5 = NR</li>
<li>UsRec8 = NR</li>
<li>UsRec12 = NR</li>
</ul></li>
<li>If <strong>&lt;current user # path 2&gt;</strong> = <strong>&lt;end of path 2 set list&gt;</strong> , then:
<ul>
<li>Clear <strong>&lt;GRead A&gt;</strong> ,</li>
<li>Clear <strong>&lt;GRead B&gt;</strong> ,</li>
<li>Clear Path 2 Run Set, and</li>
<li>Continue to Path 3.</li>
</ul></li>
<li>Else:
<ul>
<li>increment value for <strong>&lt;current user # path 2&gt;</strong> by 1 in set Path 2a Run Set</li>
<li>Clear <strong>&lt;GRead A&gt;</strong></li>
<li>Clear <strong>&lt;GRead B&gt;</strong> , and</li>
<li>Go to Path 2a User Evaluation.</li>
</ul></li>
</ol>
<p><em>Path 3</em></p>
<ol style="list-style-type: decimal">
<li>Load Path 3 Set List.</li>
<li>Count users in set = <strong>&lt;end of path 3 set list&gt;</strong>.</li>
</ol>
<p><em>Path 3 User Evaluation</em></p>
<ol style="list-style-type: decimal">
<li>Evaluate user <strong>&lt;current user # path 3 set list&gt;</strong>.</li>
<li>If user <strong>&lt;current user #&gt;</strong> UsRec7 = Dependent, then:
<ul>
<li>evaluate the following:
<ul>
<li>If UsRec2 ≥ 2, then:
<ul>
<li>add user to Path 4 Set List.</li>
</ul></li>
<li>Else:
<ul>
<li>add user to Path 2b Set List</li>
<li>update UsRec8 = Quit.</li>
</ul></li>
</ul></li>
</ul></li>
<li>Elseif (UsRec7 = Independent), then:
<ul>
<li>add user to Path 4 Set List.</li>
</ul></li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of path 3 set list&gt;</strong> , then:
<ul>
<li>go to Path 2b.</li>
</ul></li>
<li>Else:
<ul>
<li>continue to <strong>&lt;current user #&gt;</strong> + 1</li>
<li>go to Path 3 User Evaluation.</li>
</ul></li>
</ol>
<p><em>Path 2</em></p>
<ol style="list-style-type: decimal">
<li>Decrement SyRec1 by 1.</li>
<li>Increment SyRec7 by 1.</li>
<li>Referencing UsRec3,
<ul>
<li>Decrease UsRec4 by 1 for all users with same UsRec3 value.</li>
<li>Decrease UsRec2 by 1 for all users with same UsRec 1 and UsRec3.</li>
</ul></li>
<li>If UsRec8 = Quit, then:
<ul>
<li>UsRec3 = 0</li>
<li>UsRec4 = 0</li>
<li>UsRec5 = NR</li>
<li>UsRec8 = NR</li>
<li>UsRec12 = NR</li>
</ul></li>
<li>Continue to Path 2b User Evaluation.</li>
</ol>
<p><em>Path 2b User Evaluation</em></p>
<ol style="list-style-type: decimal">
<li>Start with user <strong>&lt;current user # path 2&gt;</strong> in set Path 2b Run Set.</li>
<li>Read <strong>&lt;current user #&gt;</strong> UsRec3 = Load into <strong>&lt;GRead A&gt;</strong>.</li>
<li>Read <strong>&lt;current user #&gt;</strong> UsRec1 = Load into <strong>&lt;GRead B&gt;</strong>.</li>
<li>For every user in record where UsRec3 = <strong>&lt;GRead A&gt;</strong> do:
<ul>
<li>decrease UsRec4 by 1.</li>
</ul></li>
<li>For every user in record where UsRec 3 = &lt;GRead A&gt; and UsRec 1 = &lt;GRead B&gt;, do:
<ul>
<li>decrease UsRec2 by 1.</li>
</ul></li>
<li>Assign the current values for &lt;current user # path 2&gt; as follows:
<ul>
<li>UsRec3 = 0</li>
<li>UsRec4 = 0</li>
<li>UsRec5 = NR</li>
<li>UsRec8 = NR</li>
<li>UsRec12 = NR</li>
</ul></li>
<li>If <strong>&lt;current user # path 2&gt;</strong> = <strong>&lt;end of path 2 set list&gt;</strong> then:
<ul>
<li>Clear <strong>&lt;GRead A&gt;</strong> ,</li>
<li>Clear <strong>&lt;GRead B&gt;</strong> ,</li>
<li>Clear Path 2 Run Set, and</li>
<li>Continue to Path 4.</li>
</ul></li>
<li>Else:
<ul>
<li>Increment value for <strong>&lt;current user # path 2&gt;</strong> by 1 in set Path 2b Run Set,</li>
<li>Clear <strong>&lt;GRead A&gt;</strong> ,</li>
<li>Clear <strong>&lt;GRead B&gt;</strong> , and</li>
<li>Go to Path 2b User Evaluation.</li>
</ul></li>
</ol>
<p><em>Path 4</em></p>
<ol style="list-style-type: decimal">
<li>Load Path 4 Set List.</li>
<li>Count users in set = <strong>&lt;path 4 set list&gt;</strong>.</li>
<li>For all users in Path 4 Set List do:
<ul>
<li>Increment SyRec8 by 1.</li>
<li>If UsRec8 is not Paid-Invalid, then:
<ul>
<li>throw error</li>
<li>terminate.</li>
</ul></li>
<li>If UsRec2 &lt; 2, then:
<ul>
<li>throw error</li>
<li>terminate.</li>
</ul></li>
</ul></li>
<li>Clear Path 2 Run Set.</li>
<li>Clear Path 3 Run Set.</li>
<li>Continue to SyFunc7.</li>
</ol>
<h4 id="syfunc7-detailed-description"><span class="header-section-number">10.6.1.7</span> SyFunc7 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc7 – Reorg user function</p>
<p><strong>Stage:</strong> Reorg Stage 2</p>
<p><strong>SyFunc7 workflow:</strong> The workflow of SyFunc7 is shown below in Figure 5.</p>
<div class="figure">
<img src="images/figure5.png" />
</div>
<p><strong>Figure 5. SyFunc7 Workflow</strong></p>
<p><em>Path 0 Initialization</em></p>
<ol style="list-style-type: decimal">
<li>Load user record.</li>
<li>Create user list from user record where UsRec8 = Paid-Invalid.
<ul>
<li>Count users in list = <strong>&lt;end of user list&gt;</strong>.</li>
</ul></li>
<li>Load user list.</li>
<li>Start with first user in user list <strong>&lt;current user #&gt;</strong>.</li>
</ol>
<p><em>Path 0 Start</em></p>
<ol style="list-style-type: decimal">
<li>Evaluate <strong>&lt;current user #&gt;</strong>.</li>
<li>If user <strong>&lt;current user #&gt;</strong> UsRec4 = 1, then:
<ul>
<li>add to Path 1 Run Set.</li>
</ul></li>
<li>Else:
<ul>
<li>continue.</li>
</ul></li>
<li>If user <strong>&lt;current user #&gt;</strong> UsRec4 = 2, then:
<ul>
<li>add to Path 2 Run Set.</li>
</ul></li>
<li>Else:
<ul>
<li>continue.</li>
</ul></li>
<li>If user <strong>&lt;current user #&gt;</strong> UsRec4 = 3, then:
<ul>
<li>add to Path 3 Run Set.</li>
</ul></li>
<li>Else:
<ul>
<li>if UsRec4 = 4, 5, 6, or 7, then:
<ul>
<li>throw error</li>
<li>terminate.</li>
</ul></li>
</ul></li>
<li>If <strong>&lt;current user #&gt;</strong> = <strong>&lt;end of user list&gt;</strong> , then:
<ul>
<li>load Path 1.</li>
</ul></li>
<li>Else:
<ul>
<li>continue to <strong>&lt;current user #&gt;</strong> + 1</li>
<li>go to Path 0 Start.</li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<p><strong>Path 1 First Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>For all users where UsRec4 = 1 do:
<ul>
<li>Load Path 1 Run Set.</li>
<li>Create a list from set.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P1 UsRec3 invalid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
</ul></li>
<li>Load user record.</li>
<li>Filter records that satisfy the following requirements:
<ul>
<li>User record UsRec5 = Valid and user record UsRec4 = 6.</li>
<li>Create a list from record.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P1 UsRec3 valid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
</ul></li>
</ol>
<p><strong>Path 1 Assignment First Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Start at current entry on list <strong>&lt;P1 UsRec3 invalid list&gt;</strong>.</li>
<li>Current entry = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Match with random entry from <strong>&lt;P1 UsRec3 valid list&gt;</strong> = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Find users from Path 1 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Update with the following values:
<ul>
<li>UsRec3 = &lt;UsRec3 GiveMatch&gt;
<ul>
<li>UsRec4 = 7</li>
<li>UsRec5 = Valid</li>
<li>UsRec8 = Reorg</li>
<li>UsRec9 = UsRec9 + 1</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P1 UsRec3 invalid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong></li>
<li>Remove users from Path 1 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Find users from user record where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Assign UsRec4 = 7.</li>
<li>Remove entry on <strong>&lt;P1 UsRec3 valid list&gt;</strong> where UsRec 3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 GiveMatch&gt;</strong> and <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>If <strong>&lt;P1 UsRec3 invalid list&gt;</strong> is empty, then:
<ul>
<li>check if Path 1 Run Set is empty.</li>
<li>If Path 1 Run Set is empty, then:
<ul>
<li>clear <strong>&lt;P1 UsRec3 valid list&gt;</strong></li>
<li>continue to Path 2.</li>
</ul></li>
</ul></li>
<li>Else:
<ul>
<li>throw an error.</li>
</ul></li>
<li>Check if <strong>&lt;P1 UsRec3 valid list&gt;</strong> is empty.
<ul>
<li>If <strong>&lt;P1 UsRec3 valid list&gt;</strong> is empty, then:
<ul>
<li>try Path 1 Second Attempt.</li>
</ul></li>
<li>Else:
<ul>
<li>return to Path 1 Assignment First Attempt.</li>
</ul></li>
</ul></li>
</ol>
<p><strong>Path 1 Second Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Load user record.</li>
<li>Filter records that satisfy the following requirements:
<ul>
<li>User record UsRec5 = Valid and</li>
<li>User record UsRec4 = 5.</li>
</ul></li>
<li>Create a list from record.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P1 UsRec3 valid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
</ol>
<p><strong>Path 1 Assignment Second Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Start at current entry on list <strong>&lt;P1 UsRec3 invalid list&gt;</strong>.</li>
<li>Current entry = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Match with random entry from <strong>&lt;P1 UsRec3 valid list&gt;</strong> = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Find users from Path 1 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.
<ul>
<li>Update with the following values:
<ul>
<li>UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong></li>
<li>UsRec4 = 6</li>
<li>UsRec 5 = Valid</li>
<li>UsRec 8 = Reorg</li>
<li>Increment UsRec9 by 1.</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P1 UsRec3 invalid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Remove users from Path 1 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Find users from user record where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.
<ul>
<li>Update UsRec4 = 6.</li>
</ul></li>
<li>Remove entry on <strong>&lt;P1 UsRec3 valid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 GiveMatch&gt;</strong> and <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>If <strong>&lt;P1 UsRec3 invalid list&gt;</strong> is empty, then:
<ul>
<li>If Path 1 Run Set is empty, then:
<ul>
<li>clear <strong>&lt;P1 UsRec3 valid list&gt;</strong></li>
<li>proceed to Path 2.</li>
</ul></li>
<li>Else:
<ul>
<li>throw an error.</li>
</ul></li>
</ul></li>
<li>Else:
<ul>
<li>return to Path 1 Assignment Second Attempt.</li>
</ul></li>
</ol>
<p><strong>Path 2</strong></p>
<p><strong>Path 2 First Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>For all users where UsRec4 = 2 do:
<ul>
<li>load Path 2 Run Set.</li>
</ul></li>
<li>Create a list from Path 2 Run Set.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P2 UsRec3 invalid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
<li>Load user record.
<ul>
<li>Filter records that satisfy the following requirements:
<ul>
<li>UsRec5 = Valid and</li>
<li>UsRec4 = 5.</li>
</ul></li>
<li>Create a list from record.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P2 UsRec3 valid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
</ul></li>
</ol>
<p><strong>Path 2 Assignment First Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Start at current entry on list <strong>&lt;P2 UsRec3 invalid list&gt;</strong>.</li>
<li>Current entry = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Match with random entry from <strong>&lt;P2 UsRec3 valid list&gt;</strong> = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.
<ul>
<li>Find users from Path 2 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Update with the following values:
<ul>
<li>UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>UsRec4 = 7</li>
<li>UsRec 5 = Valid</li>
<li>UsRec 8 = Reorg</li>
<li>Increment UsRec9 by 1.</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P2 UsRec3 invalid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Remove users from Path 2 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Find users from user record where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.
<ul>
<li>Update UsRec4 = 7.</li>
</ul></li>
<li>Remove entry on <strong>&lt;P2 UsRec3 valid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>If &lt;P2 UsRec3 invalid list&gt; is empty, then:
<ul>
<li>If Path 2 Run Set is empty, then:
<ul>
<li>clear <strong>&lt;P2 UsRec3 valid list&gt;</strong></li>
<li>proceed to Path 3.</li>
</ul></li>
<li>Else:
<ul>
<li>throw an error.</li>
</ul></li>
</ul></li>
<li>Else:
<ul>
<li>If <strong>&lt;P2 UsRec3 valid list&gt;</strong> is empty, then:
<ul>
<li>try Path 2 Second Attempt.</li>
</ul></li>
<li>Else:
<ul>
<li>return to Path 2 Assignment First Attempt.</li>
</ul></li>
</ul></li>
</ol>
<p><strong>Path 2 Second Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Load user record.</li>
<li>Filter records that satisfy the following requirements:
<ul>
<li>UsRec5 = Valid and</li>
<li>UsRec4 = 4.</li>
</ul></li>
<li>Create a list from record.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P2 UsRec3 valid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
</ol>
<p><strong>Path 2 Assignment Second Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Start at current entry on list <strong>&lt;P2 UsRec3 invalid list&gt;</strong>.
<ul>
<li>Current entry = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
</ul></li>
<li>Match with random entry from <strong>&lt;P2 UsRec3 valid list&gt;</strong> = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Find users from Path 2 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.
<ul>
<li>Update the following values:
<ul>
<li>UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong></li>
<li>UsRec4 = 6</li>
<li>UsRec5 = Valid</li>
<li>UsRec8 = Reorg</li>
<li>Increment UsRec9 by 1.</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P2 UsRec3 invalid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Remove users from Path 2 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Find users from user record where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.
<ul>
<li>Update UsRec4 = 6.</li>
</ul></li>
<li>Remove entry on <strong>&lt;P2 UsRec3 valid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>If <strong>&lt;P2 UsRec3 invalid list&gt;</strong> is empty, then:
<ul>
<li>If Path 2 Run Set is empty, then:
<ul>
<li>clear <strong>&lt;P2 UsRec3 valid list&gt;</strong></li>
<li>proceed to Path 3.</li>
</ul></li>
<li>Else:
<ul>
<li>throw an error.</li>
</ul></li>
</ul></li>
<li>Else:
<ul>
<li>return to Path 2 Assignment Second Attempt.</li>
</ul></li>
</ol>
<p><strong>Path 3</strong></p>
<p><strong>Path 3 First Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>For all users where UsRec4 = 3, load Path 3 Run Set. -. Create a list from set. -. Add all UsRec3 values to <strong>&lt;P3 UsRec3 invalid list&gt;</strong>. -. Eliminate all duplicates.</li>
<li>If set has two or more values, then go to Path 3 Assignment First Attempt.</li>
<li>Else, go to Path 3 Assignment Second Attempt.</li>
</ol>
<p><strong>Path 3 Assignment First Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Start at current entry on list <strong>&lt;P3 UsRec3 invalid list&gt;</strong>.
<ul>
<li>Current entry = <strong>&lt;UsRec3 NeedMatch&gt;.</strong></li>
</ul></li>
<li>Match with next entry from <strong>&lt;P3 UsRec3 invalid list&gt;</strong> = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Find users from Path 3 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.
<ul>
<li>Update with the following values:
<ul>
<li>UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong></li>
<li>UsRec4 = 6</li>
<li>UsRec5 = Valid</li>
<li>UsRec8 = Reorg</li>
<li>Increment UsRec9 by 1.</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P3 UsRec3 invalid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Remove users from Path 3 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>Find users from user record where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.
<ul>
<li>Update the following:
<ul>
<li>UsRec4 = 6</li>
<li>UsRec5 = Valid</li>
<li>UsRec8 = Reorg</li>
<li>Increment UsRec9 by 1.</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P3 UsRec3 invalid list&gt;</strong> where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Remove users from Path 3 Run Set where UsRec3 = <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 GiveMatch&gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 NeedMatch&gt;</strong>.</li>
<li>If <strong>&lt;P3 UsRec3 invalid list&gt;</strong> is empty, then:
<ul>
<li>If Path 3 Run Set is empty, then:
<ul>
<li>END FUNCTION.</li>
</ul></li>
<li>Else:
<ul>
<li>throw an error.</li>
</ul></li>
</ul></li>
<li>Else:
<ul>
<li>If <strong>&lt;P3 UsRec3 invalid list&gt;</strong> has two or more values, then:
<ul>
<li>return to Path 3 Assignment First Attempt.</li>
</ul></li>
<li>Else:
<ul>
<li>go to Path 3 Second Attempt.</li>
</ul></li>
</ul></li>
</ol>
<p><strong>Path 3 Second Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Load user record.</li>
<li>Filter records that satisfy the following requirements:
<ul>
<li>UsRec5 = Valid and</li>
<li>UsRec4 = 4.</li>
</ul></li>
<li>Create a list from record.
<ul>
<li>Add all UsRec3 values to <strong>&lt;P3 UsRec3 valid list&gt;</strong>.</li>
<li>Eliminate all duplicates.</li>
</ul></li>
</ol>
<p><strong>Path 3 Assignment Second Attempt</strong></p>
<ol style="list-style-type: decimal">
<li>Start at current entry on list <strong>&lt;P3 UsRec3 invalid list&gt;</strong>.
<ul>
<li>Current entry = <strong>&lt;UsRec3 NeedMatch&amp;gt;</strong>.</li>
</ul></li>
<li>Match with random entry from <strong>&lt;P3 UsRec3 valid list&amp;gt;</strong> = <strong>&lt;UsRec3 GiveMatch&amp;gt;</strong>.</li>
<li>Find users from Path 3 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&amp;gt;</strong>.
<ul>
<li>Update with the following values:
<ul>
<li>UsRec3 = <strong>&lt;UsRec3 GiveMatch&amp;gt;</strong></li>
<li>UsRec4 = 7</li>
<li>UsRec5 = Valid</li>
<li>UsRec8 = Reorg</li>
<li>Increment UsRec9 by 1.</li>
</ul></li>
</ul></li>
<li>Remove entry on <strong>&lt;P3 UsRec3 invalid list&amp;gt;</strong> where UsRec3 = <strong>&lt;UsRec3 NeedMatch&amp;gt;</strong>.</li>
<li>Remove users from Path 3 Run Set where UsRec3 = <strong>&lt;UsRec3 NeedMatch&amp;gt;</strong>.</li>
<li>Find users from user record where UsRec3 = <strong>&lt;UsRec3 GiveMatch&amp;gt;</strong>.
<ul>
<li>Update UsRec4 = 7.</li>
</ul></li>
<li>Remove entry on <strong>&lt;P3 UsRec3 valid list&amp;gt;</strong> where UsRec3 = <strong>&lt;UsRec3 GiveMatch&amp;gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 GiveMatch&amp;gt;</strong>.</li>
<li>Reset <strong>&lt;UsRec3 NeedMatch&amp;gt;</strong>.</li>
<li>If <strong>&lt;P3 UsRec3 invalid list&amp;gt;</strong> is empty, then:
<ul>
<li>If Path 3 Run Set is empty, then:
<ul>
<li>clear <strong>&lt;P3 UsRec3 valid list&amp;gt;</strong></li>
<li>END FUNCTION.</li>
</ul></li>
<li>Else:
<ul>
<li>throw an error.</li>
</ul></li>
</ul></li>
<li>Else:
<ul>
<li>If <strong>&lt;P3 UsRec3 valid list&amp;gt;</strong> is empty, then:
<ul>
<li>throw an error.</li>
</ul></li>
<li>Else:
<ul>
<li>return to Path 3 Assignment Second Attempt.</li>
</ul></li>
</ul></li>
</ol>
<h4 id="syfunc8-detailed-description"><span class="header-section-number">10.6.1.8</span> SyFunc8 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc8 – Claims/refunds function</p>
<p><strong>Stage:</strong> Reorg Stage 4</p>
<p><strong>SyFunc8 input:</strong> EV3 and the Period Number</p>
<p>Evaluate the period number as follows:</p>
<ol style="list-style-type: decimal">
<li>If the Period Number = 0, then:
<ul>
<li>end the function.</li>
</ul></li>
<li>Else:
<ul>
<li>continue SyFunc8.</li>
</ul></li>
<li>Calculate the probability of SyRec16 (Boolean), given EV3 as follows:
<ul>
<li>If no, then:
<ul>
<li>write SyRec2 to SyRec17.</li>
</ul></li>
<li>If yes, then:
<ul>
<li>do nothing.</li>
</ul></li>
</ul></li>
<li>Continue to SyFunc9.</li>
</ol>
<h4 id="syfunc9-detailed-description"><span class="header-section-number">10.6.1.9</span> SyFunc9 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc9 – Pricing function</p>
<p><strong>Stage:</strong> Reorg Stage 5</p>
<ol style="list-style-type: decimal">
<li>Calculate SyRec2.
<ul>
<li><img src="images/f22.png" height="30"></li>
</ul></li>
<li>Calculate SyRec14.
<ul>
<li>SyRec14 = SyRec9 + SyRec11 + SyRec13</li>
</ul></li>
<li>Calculate SyRec15.
<ul>
<li><img src="images/f23.png" height="30"></li>
</ul></li>
<li>Calculate UsRec11.
<ul>
<li>UsRec 11 = SyRec2 + SyRec15 - SyRec18 or UsRec 11 = SyRec2 + SyRec15 - UsRec10</li>
<li>If UsRec10 is used to calculate UsRec11, then:
<ul>
<li>assign UsRec10 = 0 after calculating UsRec11.</li>
</ul></li>
</ul></li>
<li>Calculate SyRec19.
<ul>
<li>SyRec19 = SyRec2 + SyRec15</li>
</ul></li>
<li>Continue to SyFunc10.</li>
</ol>
<p><strong>Note:</strong> SyFunc9 provides output for individual user.</p>
<p><strong>Note:</strong> The ability to calculate UsRec11 using two different methods prevents the same refund from being counted twice.</p>
<p><strong>Note:</strong> Setting UsRec10 = 0 after UsRec10 is used to calculate UsRec11 prevents the same refund from being counted twice.</p>
<h4 id="syfunc10-detailed-description"><span class="header-section-number">10.6.1.10</span> SyFunc10 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc10 – Account for fracture debt (Invalid or Skipped)</p>
<p><strong>Stage:</strong> Reorg Stage 6</p>
<ol style="list-style-type: decimal">
<li>Calculate SyRec10.
<ul>
<li>SyRec10 = SyRec5 * SyRec19</li>
</ul></li>
<li>Calculate SyRec12.
<ul>
<li>SyRec12 = SyRec6 * SyRec19</li>
</ul></li>
<li>Continue to SyFunc11.</li>
</ol>
<h4 id="syfunc11-detailed-description"><span class="header-section-number">10.6.1.11</span> SyFunc11 Detailed Description</h4>
<p><strong>Function name:</strong> SyFunc11 – Advance period</p>
<p><strong>Stage:</strong> Reorg Stage 7</p>
<p><strong>Initial check:</strong> Is the current period 10?</p>
<ol style="list-style-type: decimal">
<li>If the current period = 10, then:
<ul>
<li>Terminate</li>
<li>continue to <strong>Path 2</strong>.</li>
</ul></li>
<li>Else:
<ul>
<li>continue.</li>
</ul></li>
<li>Calculate Total.
<ul>
<li>Total = SyRec3 + SyRec5 + SyRec7</li>
</ul></li>
<li>If Total &gt; 0, then:
<ul>
<li>continue to Path 1.</li>
</ul></li>
<li>If Total = 0, then:
<ul>
<li>terminate</li>
<li>continue to Path 2.</li>
</ul></li>
</ol>
<p><em>Path 1</em></p>
<p><strong>Variable introduced:</strong></p>
<ol style="list-style-type: decimal">
<li><p>x = Current period</p></li>
<li>Advance to the next row in system record of simulation pay stage for Period x +1.</li>
<li>Copy all values from previous row.</li>
<li>Assign SyRec11 the value of SyRec10.</li>
<li>Assign SyRec13 the value of SyRec12.</li>
<li>Assign SyRec18 the value of SyRec17.</li>
<li>Assign SyRec10, SyRec12, and SyRec17 = 0.</li>
<li>Assign SyRec3, SyRec5, and SyRec6 = 0.</li>
<li>If UsRec8 is either Defected, Skipped, or Quit, then:
<ul>
<li>UsRec8 = NR</li>
<li>UsRec3 = 0</li>
<li>UsRec5 = NR</li>
<li>UsRec12 = NR</li>
</ul></li>
<li><p>Go to UsFunc</p></li>
</ol>
<p><em>Path 2</em></p>
<ol style="list-style-type: decimal">
<li>Write the following to a log file:
<ul>
<li>Log1 = EV1 = Z, where &lt;x&gt; is the number of members at the start of the simulation</li>
<li>Log2 = SyRec1 (final period) = Y, where &lt;x&gt; is the number of valid members remaining at the end of the simulation</li>
<li><img src="images/f24.png" height=30> = &lt;x&gt;% of policyholders that left the group by end of simulation</li>
<li>Log4 = SyRec19 (Period 1) = B, where &lt;x&gt; was the initial premium members were asked to pay</li>
<li>Log5 = SyRec19 (final period) = A, where &lt;x&gt; is the final premium members were asked to pay</li>
<li><img src="images/f25.png" height=30> = &lt;x&gt;% increase of premiums by the end of the simulation</li>
<li>Log7 = SyRec3 (Period 0 Finalize) = C</li>
<li>Log8 = EV4 = &lt;x&gt;% of policyholders who were assigned to Defect</li>
<li><img src="images/f26.png" height=30> = &lt;x&gt;% of policyholders who actually defected</li>
<li>Log10 = PV5 = &lt;x&gt;% of the initial collapse threshold set for PV5</li>
</ul></li>
<li>For single runs do:
<ul>
<li>store the table of system record as a .csv file.</li>
</ul></li>
</ol>
<p>See the additional specification for automating the simulation and performing cumulative runs testing the collapse threshold:</p>
<p>[insert specification for multiple simulation runs here]</p>
<h1 id="what-the-protocol-might-do-one-day"><span class="header-section-number">11</span> What the protocol might do one day</h1>
<p>Questions the simulation might be able to answer are as follows:</p>
<ol style="list-style-type: decimal">
<li>Chart the cumulative number of defections over the course of the simulation. At termination, did the community collapse?
<ul>
<li>Iterative runs = the boundary condition for system input variables that produce community collapse.</li>
</ul></li>
<li>What percentage of honest participants are required to produce groups which collapse?</li>
<li>How do the different variable inputs contribute to changing the collapse threshold?
<ul>
<li>Collapse is x% likely to occur with x% of initial defectors = modifying all other variables</li>
</ul></li>
</ol>
</body>
</html>
